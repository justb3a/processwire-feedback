<?php namespace ProcessWire;

use PhilipBrown\Signature\Auth;
use PhilipBrown\Signature\Token;
use PhilipBrown\Signature\Request;
use PhilipBrown\Signature\Guards\CheckKey;
use PhilipBrown\Signature\Guards\CheckVersion;
use PhilipBrown\Signature\Guards\CheckTimestamp;
use PhilipBrown\Signature\Guards\CheckSignature;
use PhilipBrown\Signature\Exceptions\SignatureException;

/**
* Feedback
*
* See README.md for usage instructions.
*
* @author Tabea David <info@justonestep.de>
* @version 0.0.6
* @copyright Copyright (c) 2017
* @see https://github.com/justonestep/processwire-feedback
* @see http://www.processwire.com
*/

/**
* Class Feedback
*/
class Feedback extends WireData implements Module {

  /**
   * Get module information
   *
   * @return array
   */
  public static function getModuleInfo() {
    return array(
      'title' => 'Feedback',
      'summary' => 'Save feedack received via json and display it (backend).',
      'version' => 006,
      'href' => 'https://github.com/justonestep/processwire-feedback',
      'singular' => true,
      'autoload' => true,
      'icon' => 'share',
      'installs' => 'ProcessFeedback'
    );
  }

  /**
   * string template name
   */
  const TEMPLATE_NAME = 'feedback';

  /**
   * string tag name
   */
  const TAG_NAME = 'feedback';

  /**
   * field name whether the entry has been viewed
   */
  const FIELD_VIEWED = 'feedback_viewed';

  /**
   * Initialize the module - ready
   *
   * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
   * when ProcessWire's API is ready. As a result, this is a good place to attach hooks.
   */
  public function ready() {
    $this->addHookBefore('Modules::saveModuleConfigData', $this, 'addFields');

    require_once($this->config->paths->{$this->className} . 'vendor/autoload.php');
  }

  /**
   *
   */
  public function sendFeedback($params) {
    $path = $this->pages->get($this->saveMessagesParent)->httpUrl;

    // correct path, fix for multisite testing
    // if path is something like `http://main.sittehttp://current.site/endpoint/`
    if (strrpos($path, 'http') !== 0) $path = substr($path, strrpos($path, 'http'));

    $http = new WireHttp;
    $http->setHeader('content-type', 'application/json; charset=utf-8');
    // $http->setHeader('apiUser', $this->apiUser); // api key: rename apiuser:apikey - key:secret @todo!!

    if ($this->authentication === 'sha') {
      $token = new Token($this->apiUser, $this->apiKey);
      $request = new Request('POST', $path, $params);
      $authParams = $request->sign($token);
      $queryParams = array_merge($authParams, $params);
    } else {
      $http->setHeader('Authorization: Basic', base64_encode("{$this->apiUser}:{$this->apiKey}"));
      $queryParams = $params;
    }

    return $http->post($path, json_encode($queryParams));
  }

  /**
   *
   */
  public function saveFeedback() {
    // only accept post requests
    if (strtolower($_SERVER['REQUEST_METHOD']) !== 'post') return $this->setErrorResponse(1);

    // only accept content type "application/json"
    $contentType = strtolower($_SERVER['CONTENT_TYPE']);
    if (strpos($contentType, 'application/json') === false) return $this->setErrorResponse(2);

    // handle empty response
    $params = $this->getPassedParams();
    if (!$params) return $this->setErrorResponse(3);

    // validate authentication
    if ($this->authentication === 'sha') {
      if (!$this->isValidHashedAuthentification($params)) return $this->setErrorResponse(4);
    } else {
      if (!$this->isValidHttpBasicAuthentification($params)) return $this->setErrorResponse(4);
    }

    // build form
    $form = $this->buildAndProcessForm($params);

    // evaluate form
    if ($form->getErrors()) return $this->getErrorsAndSetResponse($form);

    // save feedback
    $success = $this->createFeedback($params);
    if (!$success) return $this->setErrorResponse(5);

    return $this->setSuccessResponse();
  }

  /**
   *
   */
  private function getPassedParams() {
    $params = null;

    if ($json = json_decode(@file_get_contents('php://input'), true)) {
      $params = array_merge($_REQUEST, $json);

      if (isset($_SERVER['HTTP_AUTHORIZATION'])) {
        $ha = base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6) );
        list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) = explode(':', $ha);
      }

      // basic HTTP authetication
      if (isset($_SERVER['PHP_AUTH_USER'])) {
        $credentials = array(
          'fname' => $_SERVER['PHP_AUTH_USER'],
          'fpass' => $_SERVER['PHP_AUTH_PW']
        );

        $params = array_merge($params, $credentials);
      }

      // remove path
      if (isset($params['it'])) unset($params['it']);
    }

    return $params;
  }

  /**
   *
   */
  private function isValidHttpBasicAuthentification($params) {
    $isCorrectUser = isset($params['fname']) && $params['fname'] === $this->apiUser;
    $isCorrectPass = isset($params['fpass']) && $params['fpass'] === $this->apiKey;

    return $isCorrectUser && $isCorrectPass;
  }

  /**
   *
   */
  private function isValidHashedAuthentification($params) {
    $path = $this->pages->get($this->saveMessagesParent)->httpUrl;
    $isValid = true;
    $auth  = new Auth('POST', $path, $params, array(
      new CheckKey,
      new CheckVersion,
      new CheckTimestamp,
      new CheckSignature
    ));

    $token = new Token($this->apiUser, $this->apiKey);

    try {
      $auth->attempt($token);
    } catch (SignatureException $e) {
      $isValid = false;
    }

    return $isValid;
  }

  /**
   *
   */
  private function buildAndProcessForm($params) {
    $form = $this->modules->get('InputfieldForm');
    $form->method = 'post';

    // add fields, set field values
    foreach ($this->allFields as $in) {
      $key = str_replace(self::TAG_NAME . '_', '', $in);
      $field = $this->fields->get($in);
      $inputfield = $field->getInputfield($this->page);
      $form->append($inputfield);
      if (isset($params[$key])) $this->input->post[$in] = $params[$key];
    }

    // add CSRF token
    $this->input->post[$this->session->CSRF->getTokenName()] = $this->session->CSRF->getTokenValue();

    // process input, send and validate form
    $form->processInput($this->input->post);

    return $form;
  }

  // create the new page
  /**
   *
   */
  private function createFeedback($params) {
    $date = new \DateTime();
    $name = array($date->getTimestamp());

    if ($parts = $this->saveMessagesScheme) {
      foreach ($parts as $part) {
        $key = str_replace(self::TAG_NAME . '_', '', $part);
        if (isset($params[$key])) $name[] = $params[$key];
      }
    }

    if (count($name) > 1) unset($name[0]);
    $pageName = implode(' ', $name);

    $p = new Page();
    $p->template = $this->sanitizer->text(self::TEMPLATE_NAME);
    $p->parent = $this->pages->get($this->saveMessagesParent);
    $p->title = $this->sanitizer->text($pageName);

    foreach ($this->allFields as $in) {
      $key = str_replace(self::TAG_NAME . '_', '', $in);
      if (isset($params[$key])) $p->$in = $params[$key];
    }

    $p->save();

    return $p->id ? true : false;
  }

  /**
   *
   */
  private function setSuccessResponse() {
    http_response_code(201);
    return json_encode(array('success' => true));
  }

  /**
   *
   */
  private function getErrorsAndSetResponse($form) {
    $errors = array();
    foreach ($form->children as $in) {
      if ($err = $in->getErrors()) {
        $key = str_replace(self::TAG_NAME . '_', '', $in->name);
        $errors[$key] = $err[0];
      }
    }

    return $this->setErrorResponse(999, $errors);
  }

  /**
   *
   */
  private function setErrorResponse($reason, $errors = array()) {
    switch ($reason) {
      case 1:
        $code = 400;
        $error = 'incorrect_request_method';
        $msg = $this->_('Incorrect request method.');
        break;
      case 2:
        $code = 400;
        $error = 'incorrect_content_type';
        $msg = $this->_('Incorrect content type.');
        break;
      case 3:
        $code = 400;
        $error = 'missing_parameters';
        $msg = $this->_('Parameters are missing.');
        break;
      case 4:
        $code = 401;
        $error = 'incorrect_client_credentials';
        $msg = $this->_('Authorization failed.');
        break;
      case 5:
        $code = 503;
        $error = 'error_saving_request';
        $msg = $this->_('Page could not be successfully created.');
        break;
      case 999:
        $code = 400;
        $error = 'validation_error';
        $msg = $this->_('Validation error.');
        break;
      default:
        $code = 400;
        $error = 'general_error';
        $msg = $this->_('Something went wrong.');
        break;
    }

    $data = array(
      'success' => false,
      'error' => $error,
      'error_description' => $msg
    );

    if ($errors) $data['errors'] = $errors;

    http_response_code($code);

    return json_encode($data);
  }

  /**
   * Hook create and add template fields
   *
   * @param HookEvent $event
   */
  public function addFields(HookEvent $event) {
    if ($event->arguments[0] !== $this->className) return;

    $configData = $event->arguments[1];
    $configDataOld = $this->modules->getModuleConfigData($this->className);

    // create template if it doesn't exist
    $fg = $this->createTemplate($configData);

    // auto template add / remove fields
    // compare transferred data with currently saved data
    $fieldsAdded = array_diff($configData['allFields'], $configDataOld['allFields']);
    $fieldsDeleted = array_diff($configDataOld['allFields'], $configData['allFields']);

    if ($fieldsAdded) $this->assignNewFields($fieldsAdded, $fg);
    if ($fieldsDeleted) $this->deleteFields($fieldsDeleted, $fg);

    // create and add fields
    if ($configData['addFields']) { // OR! a new field is added using ASM select
      $this->addNewFields($configData, $fg);
      $event->setArgument(1, $configData);
    }
  }

  /**
   * Create template
   *
   * @param array $configData
   * @return Fieldgroup
   */
  private function createTemplate($configData) {
    if ($template = $this->templates->get(self::TEMPLATE_NAME)) {
      $fg = $template->fieldgroup; // get existing fieldgroup
    } else {
      // new fieldgroup
      $fg = new Fieldgroup();
      $fg->name = self::TEMPLATE_NAME;
      $fg->add($this->fields->get('title')); // needed title field
      $fg->save();

      // new template
      $template = new Template();
      $template->name = self::TEMPLATE_NAME;
      $template->fieldgroup = $fg; // add the fieldgroup
      $template->slashUrls = 1;
      $template->noPrependTemplateFile = 1;
      $template->noAppendTemplateFile = 1;
      $template->tags = self::TAG_NAME;
      $template->save();

      // add field whether the entry has been viewed
      $f = new Field();
      $f->type = $this->modules->get('FieldtypeCheckbox');
      $f->name = self::FIELD_VIEWED;
      $f->label = $this->_('Viewed');
      $f->tags = self::TAG_NAME;
      $f->columnWidth = '25';
      $f->save();

      $fg->add($f); // add field to fieldgroup
      $fg->save(); // save fieldgroup
    }

    $this->validateParent($configData);

    return $fg;
  }

  /**
   * Validate parent page
   *
   * @param array $configData
   */
  private function validateParent($configData) {
    // add default for save messages parent
    if (!$configData['saveMessagesParent']) $configData['saveMessagesParent'] = $this->config->rootPageID;
    // check if selected parent allows children
    $pTemplate = $this->pages->get($configData['saveMessagesParent'])->template;
    // noChildren must be 0
    if ($pTemplate->noChildren > 0) {
      $this->log->error($this->_('Please choose another parent or change the belonging template. It must allow children.'));
    } elseif (count($pTemplate->childTemplates) > 0 && !in_array($configData['saveMessagesParent'], $pTemplate->childTemplates)) {
      // if childTemplates is set, it must contain parent->template->id
      $this->log->error(sprintf(
        $this->_("Please choose another parent or change the belonging template. AllowedTemplates must include `%s` template."),
        self::TEMPLATE_NAME
      ));
    }
  }

  /**
   * Add new fields
   *
   * @param array $configData
   * @param Fieldgroup $fg
   */
  private function addNewFields(&$configData, $fg) {
    $newFields = $configData['addFields'];
    $allFields = $configData['allFields'];

    foreach (explode(',', $newFields) as $name) {
      $taggedName = self::TAG_NAME . '_' . $name;
      if (!in_array($taggedName, $allFields)) $allFields[] = $taggedName;
      if (!is_null($this->fields->get($taggedName))) continue;

      $f = new Field();
      $f->type = $this->modules->get('FieldtypeText');
      $f->name = $taggedName;
      $f->label = ucfirst($name);
      $f->tags = self::TAG_NAME;
      $f->columnWidth = '25';
      $f->save();

      if ($fg) {
        $fg->add($f); // add field to fieldgroup
        $fg->save(); // save fieldgroup
      }
    }

    $configData['allFields'] = $allFields;
    $configData['addFields'] = '';
  }

  /**
   * Add new fields
   *
   * @param array $newFields
   * @param Fieldgroup $fg
   */
  private function assignNewFields($newFields, $fg) {
    foreach ($newFields as $name) {
      $f = $this->fields->get($name);

      if ($f && $fg) {
        $fg->add($f); // add field to fieldgroup
        $fg->save(); // save fieldgroup
      }
    }
  }

  /**
   * Delete fields
   *
   * @param array $newFields
   * @param Fieldgroup $fg
   */
  private function deleteFields($deleteFields, $fg) {
    foreach ($deleteFields as $name) {
      $f = $this->fields->get($name);

      if ($f && $fg) {
        $fg->remove($f); // remove field from fieldgroup
        $fg->save(); // save fieldgroup
      }
    }
  }

}
